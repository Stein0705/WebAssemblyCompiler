<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WASM Assembler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .container {
            width: 100%;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 30px;
            text-align: center;
        }
        
        textarea {
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 20px;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        .output {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .output h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .binary {
            font-family: 'Courier New', monospace;
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 6px;
            word-break: break-all;
            margin: 10px 0;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .result {
            padding: 15px;
            background: white;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .error {
            color: #e74c3c;
            padding: 15px;
            background: #fee;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .success {
            color: #27ae60;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔧 WASM Assembler</h1>
        
        <textarea id="code"></textarea>
        
        <button onclick="assembleAndRun()">Assemble & Run</button>
        
        <div id="output"></div>
    </div>
    
    <script>

        function encodeWasmInstruction(words) {
            // Mapping of WASM opcodes for different types
            // Take type from second word if exists valid type
            let type = "i32"; // default type
            if (words.length > 1) {
                const validTypes = ["i32", "i64", "f32", "f64"];
                if (validTypes.includes(words[1])) {
                    type = words[1];
                    words.splice(1, 1); // remove type from words
                }
            }
            
            const opcodes = {
                "get": 0x20,        // local.get (same for all types)
                "return": 0x0F,     // return
                "drop": 0x1A,      // drop
                "call": 0x10,      // call
                "add": { i32: 0x6A, i64: 0x7C, f32: 0x92, f64: 0xA0 },
                "sub": { i32: 0x6B, i64: 0x7D, f32: 0x93, f64: 0xA1 },
                "mul": { i32: 0x6C, i64: 0x7E, f32: 0x94, f64: 0xA2 },
                "div": { i32: 0x6D, i64: 0x7F, f32: 0x95, f64: 0xA3 }, // i32/i64 are signed div
                "const": { i32: 0x41, i64: 0x42, f32: 0x43, f64: 0x44 }
           
            };

            let bytes = [];

            switch(words[0]) {
                case "get":
                    bytes.push(opcodes.get);
                    bytes.push(Number(words[1]));
                    break;
                case "const":
                    bytes.push(opcodes.const[type]);
                    bytes.push(Number(words[1]));
                    break;
                case "drop":
                    bytes.push(opcodes.drop);
                    break;
                case "call":
                    bytes.push(opcodes.call);
                    bytes.push(Number(words[1]));
                    break;
                case "add":
                case "sub":
                case "mul":
                case "div":
                    bytes.push(opcodes[words[0]][type]);
                    break;
                case "return":
                    bytes.push(opcodes.return);
                    break;
                default:
                    bytes.push(Number(words[0]));
            }

            return bytes;
        }

        
        function compile(code) { // This should parse the code and return a Uint8Array of WASM binary

            // turn code string into array of lines
            const lines = code.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            if (lines.length === 0) return null;
            let compilationIndex = 0;
            
            const bytes = [];
    
            // Magic number
            bytes.push(0x00, 0x61, 0x73, 0x6D);
            
            // Version
            bytes.push(0x01, 0x00, 0x00, 0x00);

            
            let types = []
            let functions = []
            let imports = []
            let exports = []
            let codes = []
            let TempCode = []

            for (let i = 0; i < lines.length; i++){
                // split line in words
                let words = lines[i].split(' ').filter(p => p.length > 0);
                if (words.length === 0) continue;
                console.log(words)
                if (words[0] == "export"){
                    if (TempCode.length > 0){
                        codes.push(TempCode);
                        TempCode = [];
                    }
                    // get the input and outputs in format export add i32 i32 => i32 as binaries
                    let funcName = words[1];
                    let inputs = [];
                    let outputs = [];
                    let mode = "inputs"
                    for (let j = 2; j < words.length; j++){
                        if (words[j] == "=>"){
                            mode = "outputs";
                            continue;
                        }
                        if (mode == "inputs"){
                            if (words[j] == "i32") inputs.push(0x7F);
                            else if (words[j] == "i64") inputs.push(0x7E);
                            else if (words[j] == "f32") inputs.push(0x7D);
                            else if (words[j] == "f64") inputs.push(0x7C);
                        } else {
                            if (words[j] == "i32") outputs.push(0x7F);
                            else if (words[j] == "i64") outputs.push(0x7E);
                            else if (words[j] == "f32") outputs.push(0x7D);
                            else if (words[j] == "f64") outputs.push(0x7C);
                        }
                    }
                    types.push({"inputs": inputs, "outputs": outputs});
                    functions.push(types.length - 1); // function uses the last type
                    exports.push({"name": funcName});
                }
                else if (words[0] == "import"){
                    // import math pow i32 i32 => i32
                    console.log("import")
                    if (TempCode.length > 0){
                        codes.push(TempCode);
                        TempCode = [];
                    }
                    let moduleName = words[1];
                    let funcName = words[2];
                    let inputs = [];
                    let outputs = [];
                    let mode = "inputs"
                    for (let j = 3; j < words.length; j++){
                        if (words[j] == "=>"){
                            mode = "outputs";
                            continue;
                        }
                        if (mode == "inputs"){
                            if (words[j] == "i32") inputs.push(0x7F);
                            else if (words[j] == "i64") inputs.push(0x7E);
                            else if (words[j] == "f32") inputs.push(0x7D);
                            else if (words[j] == "f64") inputs.push(0x7C);
                        } else {
                            if (words[j] == "i32") outputs.push(0x7F);
                            else if (words[j] == "i64") outputs.push(0x7E);
                            else if (words[j] == "f32") outputs.push(0x7D);
                            else if (words[j] == "f64") outputs.push(0x7C);
                        }
                    }
                    types.push({"inputs": inputs, "outputs": outputs});
                    imports.push({"module": moduleName, "name": funcName, "typeIndex": types.length - 1});
                    //functions.push(types.length - 1); // function uses the last type
                    console.log(imports)

                }
                else {// add line of code to the end of the last function in  the code
                    TempCode.push(...encodeWasmInstruction(words)); // second word is type, should be removed from words argument
                }
                
            }
            if (TempCode.length > 0){
                codes.push(TempCode);
                TempCode = [];
            }
            console.log(types, functions, imports, exports, codes);
            
            // TYPE SECTION
            bytes.push(0x01); // section id

            // Calculate length
            let typesSectionLength = 1; // 1 byte for types.length
            types.forEach(t => {
                typesSectionLength += 1; // 0x60 func type marker
                typesSectionLength += 1; // inputs.length
                typesSectionLength += t.inputs.length; // actual input types
                typesSectionLength += 1; // outputs.length
                typesSectionLength += t.outputs.length; // actual output types
            });

            bytes.push(typesSectionLength); // section length
            bytes.push(types.length); // number of types
            types.forEach(t => {
                bytes.push(0x60); // func type
                bytes.push(t.inputs.length); // number of params
                t.inputs.forEach(p => bytes.push(p)); // param types
                bytes.push(t.outputs.length); // number of results
                t.outputs.forEach(r => bytes.push(r)); // result types
            });

            // import SECTION
            bytes.push(0x02); // section id
            // calculate length
            let importsSectionLength = 1; // 1 byte for imports.length
            imports.forEach(imp => {
                importsSectionLength += 1; // module name length
                importsSectionLength += imp.module.length; // module name chars
                importsSectionLength += 1; // func name length
                importsSectionLength += imp.name.length; // func name chars
                importsSectionLength += 1; // import kind (0x00)
                importsSectionLength += 1; // type index
            });
            bytes.push(importsSectionLength); // section length
            bytes.push(imports.length); // number of imports
            imports.forEach(imp => {
                bytes.push(imp.module.length); // module name length
                for (let j = 0; j < imp.module.length; j++) {
                    bytes.push(imp.module.charCodeAt(j)); // module name chars
                }
                bytes.push(imp.name.length); // func name length
                for (let j = 0; j < imp.name.length; j++) {
                    bytes.push(imp.name.charCodeAt(j)); // func name chars
                }
                bytes.push(0x00); // import kind: function
                bytes.push(imp.typeIndex); // type index
            });
            
            
            // FUNCTION SECTION: Declare 1 function using type 0
            bytes.push(0x03); // section id
            bytes.push(1 + functions.length); // section length (TODO)
            bytes.push(functions.length); // 1 function
            functions.forEach(f => bytes.push(f)); // function type index
            if (exports.length != 0){
            // EXPORT SECTION
            bytes.push(0x07); // section id

            // Calculate length: 1 byte for count + each export entry
            let exportsSectionLength = 1; // 1 byte for exports.length
            exports.forEach((exp, idx) => {
                exportsSectionLength += 1; // name length byte
                exportsSectionLength += exp.name.length; // name characters
                exportsSectionLength += 1; // export kind (0x00)
                exportsSectionLength += 1; // function index
            });

            bytes.push(exportsSectionLength); // section length
            bytes.push(exports.length); // number of exports
            exports.forEach((exp, idx) => {
                bytes.push(exp.name.length); // name length
                for (let j = 0; j < exp.name.length; j++) {
                    bytes.push(exp.name.charCodeAt(j)); // name chars
                }
                bytes.push(0x00); // export kind: function
                bytes.push(idx + imports.length); // function index + amount of imported functions
            });
        }
            
            
            // CODE SECTION
            bytes.push(0x0A); // section id

            // Calculate length: 1 byte for count + each function body
            let codesSectionLength = 1; // 1 byte for codes.length
            codes.forEach(code => {
                codesSectionLength += 1; // body size byte
                codesSectionLength += 1; // local decl count (0x00)
                codesSectionLength += code.length; // actual instructions
                codesSectionLength += 1; // end (0x0B)
            });

            bytes.push(codesSectionLength); // section length
            bytes.push(codes.length); // number of functions
            codes.forEach(code => {
                bytes.push(code.length + 2); // body size (code + local decl + end)
                bytes.push(0x00); // local decl count
                code.forEach(op => bytes.push(op)); // function body
                bytes.push(0x0B); // end
            });

            console.log(bytes);
            // Convert to Uint8Array
            return new Uint8Array(bytes);
        }
        
        async function assembleAndRun() {
            const code = document.getElementById('code').value;
            const output = document.getElementById('output');
            
            if (!code.trim()) {
                output.innerHTML = '<div class="output"><p style="color: #e74c3c;">Please enter some code.</p></div>';
                return;
            }
            
            try {
                // Compile the code to binary
                const binary = compile(code);
                
                if (!binary) {
                    output.innerHTML = `
                        <div class="output">
                            <div class="error">⚠️ Compiler not yet implemented. The compile() function needs to be filled in.</div>
                        </div>
                    `;
                    return;
                }
                
                // Display the binary
                let binaryHex = '';
                for (let i = 0; i < binary.length; i++) {
                    if (i > 0 && i % 16 === 0) binaryHex += '\n';
                    binaryHex += binary[i].toString(16).padStart(2, '0').toUpperCase() + ' ';
                }
                
                // Create and instantiate the module
                const module = await WebAssembly.compile(binary);
                const instance = await WebAssembly.instantiate(module,{
        env: {
            pow: (x, y) => x ** y, // imported function: x^y
            log: (x) => { console.log("Log from WASM:", x); return x; }
        }
    });
                
                // Get exported functions
                const exports = Object.keys(instance.exports);
                
                let resultHTML = '<div class="result"><p class="success">✓ Module compiled and instantiated successfully!</p>';
                resultHTML += '<p><strong>Exported functions:</strong> ' + exports.join(', ') + '</p>';
                
                // Try to call the first exported function if it exists and looks callable

                // try all functions
                for (const funcName of exports) {
                    const func = instance.exports[funcName];
                    
                    if (typeof func === 'function') {
                        try {
                            // Try calling with sample arguments (adjust as needed)
                            const result = func(5, 3);
                            resultHTML += `<p><strong>Test call ${funcName}(5, 3):</strong> ${result}</p>`;
                        } catch (e) {
                            resultHTML += `<p><strong>Test call ${funcName}:</strong> ${e.message}</p>`;
                        }
                    }
                }
                
                
                resultHTML += '</div>';
                
                output.innerHTML = `
                    <div class="output">
                        <h3>Binary Output (${binary.length} bytes):</h3>
                        <div class="binary">${binaryHex}</div>
                        
                        <h3>Execution Result:</h3>
                        ${resultHTML}
                    </div>
                `;
                
            } catch (error) {
                output.innerHTML = `
                    <div class="output">
                        <div class="error">
                            <strong>Error:</strong> ${error.message}
                        </div>
                    </div>
                `;
            }
        }
    </script>
</body>
</html>